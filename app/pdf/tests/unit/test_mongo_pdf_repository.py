import pytest
from mongomock_motor import AsyncMongoMockClient
from bson import ObjectId
import pytest_asyncio
import gridfs.errors
from app.pdf.domain.models import PDFDocument, PDFParseStatus
from app.pdf.infrastucture.repositories.mongo_pdf_repository import MongoPDFRepository
from app.pdf.domain.exceptions import PDFNotFoundError
import io
from datetime import datetime, timezone
from unittest.mock import AsyncMock, MagicMock

# Use pytest-asyncio marker for async tests
pytestmark = pytest.mark.asyncio


class MockAsyncIOMotorGridFSBucket(AsyncMock):
    """A mock for AsyncIOMotorGridFSBucket."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._uploaded_files = {}

    async def upload_from_stream(self, filename, source, metadata=None):
        # Simulate GridFS upload by returning a new ObjectId
        new_id = ObjectId()
        # Store the content associated with the ID (for potential future verification)
        # For this mock, we just need to know the ID exists
        self._uploaded_files[new_id] = source.read()  # Read the stream content
        return new_id

    async def open_download_stream(self, file_id):
        # Simulate GridFS download
        if ObjectId(file_id) in self._uploaded_files:
            # Return a mock stream with dummy content
            mock_stream = MagicMock()
            mock_stream.read.return_value = (
                b"mock file content"  # Still return dummy content for simplicity
            )
            return mock_stream
        else:
            # Simulate file not found
            raise gridfs.errors.NoFile(f"No file with id {file_id}")


@pytest_asyncio.fixture
async def mongo_repository():
    """Fixture to provide an in-memory MongoPDFRepository instance."""
    client = AsyncMongoMockClient()
    db = client["test_db"]
    # Manually provide a mock GridFSBucket
    mock_fs = MockAsyncIOMotorGridFSBucket()
    repository = MongoPDFRepository(db=db, fs=mock_fs)
    yield repository
    # Clean up the database after each test (mongomock handles this in memory)
    await client.drop_database("test_db")


class TestMongoPDFRepository:
    async def test_save_pdf_binary(self, mongo_repository: MongoPDFRepository):
        """
        Test saving a PDF binary to GridFS.
        Verify that a gridfs_id is returned.
        """
        filename = "test.pdf"
        content = b"fake pdf content"
        user_id = 123

        gridfs_id = await mongo_repository.save_pdf_binary(filename, content, user_id)

        assert isinstance(gridfs_id, str)
        # Check if it's a valid ObjectId string
        assert ObjectId.is_valid(gridfs_id)

    async def test_save_pdf_meta(self, mongo_repository: MongoPDFRepository):
        """
        Test saving PDF metadata to the collection.
        Verify that the PDFDocument object is returned with a generated ID.
        """
        user_id = 123
        gridfs_file_id = str(ObjectId())
        pdf_doc = PDFDocument(
            id=None,  # ID should be generated by the repository
            user_id=user_id,
            gridfs_file_id=gridfs_file_id,
            original_filename="test.pdf",
            upload_date=datetime.now(timezone.utc),
            parse_status=PDFParseStatus("UNPARSED"),
            parse_error_message=None,
            is_selected_for_chat=False,
            parsed_text_id=None,
        )

        saved_pdf_doc = await mongo_repository.save_pdf_meta(pdf_doc)

        assert saved_pdf_doc is not None
        assert isinstance(saved_pdf_doc, PDFDocument)
        assert saved_pdf_doc.id is not None
        assert ObjectId.is_valid(saved_pdf_doc.id)
        assert saved_pdf_doc.user_id == user_id
        assert saved_pdf_doc.gridfs_file_id == gridfs_file_id
        assert saved_pdf_doc.original_filename == "test.pdf"
        assert saved_pdf_doc.parse_status == PDFParseStatus.UNPARSED
        assert saved_pdf_doc.is_selected_for_chat is False

        # Verify the document exists in the collection
        inserted_doc = await mongo_repository.db["pdf_metadata_collection"].find_one(
            {"_id": ObjectId(saved_pdf_doc.id)}
        )
        assert inserted_doc is not None
        assert str(inserted_doc["gridfs_file_id"]) == gridfs_file_id
        assert inserted_doc["user_id"] == user_id

    async def test_get_pdf_meta_by_id(self, mongo_repository: MongoPDFRepository):
        """
        Test retrieving PDF metadata by its ID and user ID.
        Verify that the correct PDFDocument is returned or None if not found/not owned.
        """
        user_id = 456
        gridfs_file_id = str(ObjectId())
        pdf_doc = PDFDocument(
            id=None,
            user_id=user_id,
            gridfs_file_id=gridfs_file_id,
            original_filename="another.pdf",
            upload_date=datetime.now(timezone.utc),
            parse_status=PDFParseStatus.UNPARSED,
            parse_error_message=None,
            is_selected_for_chat=False,
            parsed_text_id=None,
        )
        saved_pdf_doc = await mongo_repository.save_pdf_meta(pdf_doc)

        # Test retrieving by correct ID and user ID
        retrieved_doc = await mongo_repository.get_pdf_meta_by_id(saved_pdf_doc.id, user_id)
        assert retrieved_doc is not None
        assert retrieved_doc.id == saved_pdf_doc.id
        assert retrieved_doc.user_id == saved_pdf_doc.user_id
        assert retrieved_doc.original_filename == saved_pdf_doc.original_filename

        # Test retrieving by incorrect ID
        non_existent_id = str(ObjectId())
        retrieved_doc_non_existent = await mongo_repository.get_pdf_meta_by_id(non_existent_id, user_id)
        assert retrieved_doc_non_existent is None

        # Test retrieving by correct ID but incorrect user ID
        wrong_user_id = 789
        retrieved_doc_wrong_user = await mongo_repository.get_pdf_meta_by_id(
            saved_pdf_doc.id, wrong_user_id
        )
        assert retrieved_doc_wrong_user is None

        # Test retrieving with invalid ID string
        invalid_id_string = "invalid-id"
        retrieved_doc_invalid_id = await mongo_repository.get_pdf_meta_by_id(invalid_id_string, user_id)
        assert retrieved_doc_invalid_id is None

    async def test_get_pdf_binary_stream_by_gridfs_id(self, mongo_repository: MongoPDFRepository):
        """
        Test retrieving a PDF binary stream by its GridFS ID.
        Verify that a stream object is returned and can be read, or None if not found.
        """
        filename = "stream_test.pdf"
        content = b"stream content"
        user_id = 999

        # Simulate saving a binary to get a GridFS ID
        gridfs_id = await mongo_repository.save_pdf_binary(filename, content, user_id)

        # Test retrieving by correct GridFS ID
        retrieved_stream = await mongo_repository.get_pdf_binary_stream_by_gridfs_id(gridfs_id)
        assert retrieved_stream is not None
        # The mock stream always returns b"mock file content"
        assert retrieved_stream.read() == b"mock file content"

        # Test retrieving by incorrect GridFS ID
        non_existent_id = str(ObjectId())
        retrieved_stream_non_existent = await mongo_repository.get_pdf_binary_stream_by_gridfs_id(
            non_existent_id
        )
        assert retrieved_stream_non_existent is None

        # Test retrieving with invalid ID string
        invalid_id_string = "invalid-gridfs-id"
        retrieved_stream_invalid_id = await mongo_repository.get_pdf_binary_stream_by_gridfs_id(
            invalid_id_string
        )
        assert retrieved_stream_invalid_id is None

    async def test_get_all_pdf_meta_for_user(self, mongo_repository: MongoPDFRepository):
        """
        Test retrieving all PDF metadata for a specific user, with pagination.
        Verify that the correct list of PDFDocuments is returned.
        """
        user_id_1 = 111
        user_id_2 = 222

        # Create documents for user 1
        docs_user_1 = []
        for i in range(5):
            doc = PDFDocument(
                id=None,
                user_id=user_id_1,
                gridfs_file_id=str(ObjectId()),
                original_filename=f"user1_doc_{i}.pdf",
                upload_date=datetime.now(timezone.utc),
                parse_status=PDFParseStatus.UNPARSED,
                parse_error_message=None,
                is_selected_for_chat=False,
                parsed_text_id=None,
            )
            saved_doc = await mongo_repository.save_pdf_meta(doc)
            docs_user_1.append(saved_doc)

        # Create documents for user 2
        docs_user_2 = []
        for i in range(3):
            doc = PDFDocument(
                id=None,
                user_id=user_id_2,
                gridfs_file_id=str(ObjectId()),
                original_filename=f"user2_doc_{i}.pdf",
                upload_date=datetime.now(timezone.utc),
                parse_status=PDFParseStatus.UNPARSED,
                parse_error_message=None,
                is_selected_for_chat=False,
                parsed_text_id=None,
            )
            saved_doc = await mongo_repository.save_pdf_meta(doc)
            docs_user_2.append(saved_doc)

        # Test retrieving all documents for user 1
        retrieved_docs_user_1_all = await mongo_repository.get_all_pdf_meta_for_user(user_id_1)
        assert len(retrieved_docs_user_1_all) == 5
        # Note: The repository sorts by upload_date descending, so the order might be reversed
        # For simplicity, we'll just check if all expected documents are present
        retrieved_ids_user_1_all = {doc.id for doc in retrieved_docs_user_1_all}
        expected_ids_user_1 = {doc.id for doc in docs_user_1}
        assert retrieved_ids_user_1_all == expected_ids_user_1

        # Test retrieving with limit
        retrieved_docs_user_1_limit_2 = await mongo_repository.get_all_pdf_meta_for_user(user_id_1, limit=2)
        assert len(retrieved_docs_user_1_limit_2) == 2

        # Test retrieving with skip and limit
        retrieved_docs_user_1_skip_2_limit_2 = await mongo_repository.get_all_pdf_meta_for_user(
            user_id_1, skip=2, limit=2
        )
        assert len(retrieved_docs_user_1_skip_2_limit_2) == 2
        # Check if the retrieved documents are from the expected range (considering sort order)
        # This requires knowing the exact upload dates or sorting the expected list
        # For now, a basic check on length is sufficient. More robust checks would involve sorting.

        # Test retrieving documents for user 2
        retrieved_docs_user_2_all = await mongo_repository.get_all_pdf_meta_for_user(user_id_2)
        assert len(retrieved_docs_user_2_all) == 3
        retrieved_ids_user_2_all = {doc.id for doc in retrieved_docs_user_2_all}
        expected_ids_user_2 = {doc.id for doc in docs_user_2}
        assert retrieved_ids_user_2_all == expected_ids_user_2

        # Test retrieving for a user with no documents
        retrieved_docs_user_3 = await mongo_repository.get_all_pdf_meta_for_user(333)
        assert len(retrieved_docs_user_3) == 0

    async def test_count_all_pdf_meta_for_user(self, mongo_repository: MongoPDFRepository):
        """
        Test counting the number of PDF metadata documents for a user.
        Verify that the correct count is returned.
        """
        user_id_1 = 111
        user_id_2 = 222

        # Create documents for user 1
        for i in range(5):
            doc = PDFDocument(
                id=None,
                user_id=user_id_1,
                gridfs_file_id=str(ObjectId()),
                original_filename=f"user1_doc_{i}.pdf",
                upload_date=datetime.now(timezone.utc),
                parse_status=PDFParseStatus.UNPARSED,
                parse_error_message=None,
                is_selected_for_chat=False,
                parsed_text_id=None,
            )
            await mongo_repository.save_pdf_meta(doc)

        # Create documents for user 2
        for i in range(3):
            doc = PDFDocument(
                id=None,
                user_id=user_id_2,
                gridfs_file_id=str(ObjectId()),
                original_filename=f"user2_doc_{i}.pdf",
                upload_date=datetime.now(timezone.utc),
                parse_status=PDFParseStatus.UNPARSED,
                parse_error_message=None,
                is_selected_for_chat=False,
                parsed_text_id=None,
            )
            await mongo_repository.save_pdf_meta(doc)

        # Test counting for user 1
        count_user_1 = await mongo_repository.count_all_pdf_meta_for_user(user_id_1)
        assert count_user_1 == 5

        # Test counting for user 2
        count_user_2 = await mongo_repository.count_all_pdf_meta_for_user(user_id_2)
        assert count_user_2 == 3

        # Test counting for a user with no documents
        count_user_3 = await mongo_repository.count_all_pdf_meta_for_user(333)
        assert count_user_3 == 0

    async def test_update_pdf_meta(self, mongo_repository: MongoPDFRepository):
        """
        Test updating existing PDF metadata.
        Verify that the document is updated in the database and the updated domain object is returned.
        Test that PDFNotFoundError is raised if the document is not found or not owned.
        """
        user_id = 777
        gridfs_file_id = str(ObjectId())
        pdf_doc = PDFDocument(
            id=None,
            user_id=user_id,
            gridfs_file_id=gridfs_file_id,
            original_filename="to_update.pdf",
            upload_date=datetime.now(timezone.utc),
            parse_status=PDFParseStatus("UNPARSED"),
            parse_error_message=None,
            is_selected_for_chat=False,
            parsed_text_id=None,
        )
        saved_pdf_doc = await mongo_repository.save_pdf_meta(pdf_doc)

        # Update the document
        saved_pdf_doc.parse_status = PDFParseStatus("PARSED_SUCCESS")
        saved_pdf_doc.parse_error_message = "No errors"
        saved_pdf_doc.is_selected_for_chat = True
        saved_pdf_doc.parsed_text_id = str(ObjectId())

        updated_pdf_doc = await mongo_repository.update_pdf_meta(saved_pdf_doc)

        assert updated_pdf_doc is not None
        assert updated_pdf_doc.id == saved_pdf_doc.id
        assert updated_pdf_doc.parse_status == PDFParseStatus.PARSED_SUCCESS
        assert updated_pdf_doc.parse_error_message == "No errors"
        assert updated_pdf_doc.is_selected_for_chat is True
        assert ObjectId.is_valid(updated_pdf_doc.parsed_text_id)

        # Verify the document is updated in the database
        db_doc = await mongo_repository.db["pdf_metadata_collection"].find_one(
            {"_id": ObjectId(updated_pdf_doc.id)}
        )
        assert db_doc is not None
        assert db_doc["parse_status"] == PDFParseStatus.PARSED_SUCCESS.value
        assert db_doc["parse_error_message"] == "No errors"
        assert db_doc["is_selected_for_chat"] is True
        assert ObjectId.is_valid(str(db_doc["parsed_text_id"]))

        # Test updating a non-existent document
        non_existent_doc = PDFDocument(
            id=str(ObjectId()),
            user_id=user_id,
            gridfs_file_id=str(ObjectId()),
            original_filename="non_existent.pdf",
            upload_date=datetime.now(timezone.utc),
            parse_status=PDFParseStatus.UNPARSED,
            parse_error_message=None,
            is_selected_for_chat=False,
            parsed_text_id=None,
        )
        with pytest.raises(PDFNotFoundError):
            await mongo_repository.update_pdf_meta(non_existent_doc)

        # Test updating a document with incorrect user ID
        wrong_user_doc = PDFDocument(
            id=saved_pdf_doc.id,
            user_id=999,  # Wrong user ID
            gridfs_file_id=saved_pdf_doc.gridfs_file_id,
            original_filename=saved_pdf_doc.original_filename,
            upload_date=saved_pdf_doc.upload_date,
            parse_status=saved_pdf_doc.parse_status,
            parse_error_message=saved_pdf_doc.parse_error_message,
            is_selected_for_chat=saved_pdf_doc.is_selected_for_chat,
            parsed_text_id=saved_pdf_doc.parsed_text_id,
        )
        with pytest.raises(PDFNotFoundError):
            await mongo_repository.update_pdf_meta(wrong_user_doc)

        # Test updating with invalid ID string
        invalid_id_doc = PDFDocument(
            id="invalid-id",
            user_id=user_id,
            gridfs_file_id=str(ObjectId()),
            original_filename="invalid_id.pdf",
            upload_date=datetime.now(timezone.utc),
            parse_status=PDFParseStatus.UNPARSED,
            parse_error_message=None,
            is_selected_for_chat=False,
            parsed_text_id=None,
        )
        with pytest.raises(PDFNotFoundError):
            await mongo_repository.update_pdf_meta(invalid_id_doc)

    async def test_set_pdf_selected_for_chat(self, mongo_repository: MongoPDFRepository):
        """
        Test setting a specific PDF as selected for chat for a user, deselecting others.
        Verify that the correct document's is_selected_for_chat status is updated and others are deselected.
        Verify the boolean return value.
        """
        user_id = 888
        # Create multiple documents for the user
        docs = []
        for i in range(3):
            doc = PDFDocument(
                id=None,
                user_id=user_id,
                gridfs_file_id=str(ObjectId()),
                original_filename=f"select_test_{i}.pdf",
                upload_date=datetime.now(timezone.utc),
                parse_status=PDFParseStatus("PARSED_SUCCESS"),  # Must be parsed to be selected
                parse_error_message=None,
                is_selected_for_chat=False,
                parsed_text_id=str(ObjectId()),
            )
            saved_doc = await mongo_repository.save_pdf_meta(doc)
            docs.append(saved_doc)

        # Select the second document
        pdf_to_select = docs[1]
        success = await mongo_repository.set_pdf_selected_for_chat(user_id, pdf_to_select.id)
        assert success is True

        # Verify the selected document is marked as selected
        selected_doc_db = await mongo_repository.db["pdf_metadata_collection"].find_one(
            {"_id": ObjectId(pdf_to_select.id)}
        )
        assert selected_doc_db is not None
        assert selected_doc_db["is_selected_for_chat"] is True

        # Verify other documents for the same user are deselected
        for i, doc in enumerate(docs):
            if i != 1:  # Skip the selected document
                other_doc_db = await mongo_repository.db["pdf_metadata_collection"].find_one(
                    {"_id": ObjectId(doc.id)}
                )
                assert other_doc_db is not None
                assert other_doc_db["is_selected_for_chat"] is False

        # Test selecting a document that is already selected
        success_already_selected = await mongo_repository.set_pdf_selected_for_chat(
            user_id, pdf_to_select.id
        )
        assert success_already_selected is True  # Should return True if already matched or modified

        # Test selecting a non-existent document
        non_existent_id = str(ObjectId())
        success_non_existent = await mongo_repository.set_pdf_selected_for_chat(user_id, non_existent_id)
        assert success_non_existent is False

        # Test selecting with invalid ID string
        invalid_id_string = "invalid-id"
        success_invalid_id = await mongo_repository.set_pdf_selected_for_chat(user_id, invalid_id_string)
        assert success_invalid_id is False

        # Test selecting for a different user (should not affect the original user's selection)
        user_id_diff = 999
        success_diff_user = await mongo_repository.set_pdf_selected_for_chat(user_id_diff, pdf_to_select.id)
        assert success_diff_user is False  # Document is not owned by this user

    async def test_save_parsed_text(self, mongo_repository: MongoPDFRepository):
        """
        Test saving parsed text content associated with a PDF metadata ID.
        Verify that a parsed_text_id is returned.
        """
        pdf_meta_id = str(ObjectId())
        text_content = "This is the parsed text content."

        parsed_text_id = await mongo_repository.save_parsed_text(pdf_meta_id, text_content)

        assert isinstance(parsed_text_id, str)
        assert ObjectId.is_valid(parsed_text_id)

        # Verify the document exists in the parsed texts collection
        inserted_doc = await mongo_repository.db["parsed_pdf_texts_collection"].find_one(
            {"_id": ObjectId(parsed_text_id)}
        )
        assert inserted_doc is not None
        assert str(inserted_doc["pdf_metadata_id"]) == pdf_meta_id
        assert inserted_doc["text_content"] == text_content
        assert "created_at" in inserted_doc
        assert isinstance(inserted_doc["created_at"], datetime)

    async def test_get_parsed_text_by_pdf_meta_id(self, mongo_repository: MongoPDFRepository):
        """
        Test retrieving parsed text content by PDF metadata ID.
        Verify that the correct text content is returned or None if not found.
        """
        # Save some parsed text first
        pdf_meta_id = str(ObjectId())
        text_content = "Some parsed text."
        await mongo_repository.save_parsed_text(pdf_meta_id, text_content)

        # Test retrieving by correct PDF metadata ID
        retrieved_text = await mongo_repository.get_parsed_text_by_pdf_meta_id(pdf_meta_id)
        assert retrieved_text == text_content

        # Test retrieving by incorrect PDF metadata ID
        non_existent_id = str(ObjectId())
        retrieved_text_non_existent = await mongo_repository.get_parsed_text_by_pdf_meta_id(non_existent_id)
        assert retrieved_text_non_existent is None

        # Test retrieving with invalid ID string
        invalid_id_string = "invalid-id"
        retrieved_text_invalid_id = await mongo_repository.get_parsed_text_by_pdf_meta_id(invalid_id_string)
        assert retrieved_text_invalid_id is None
